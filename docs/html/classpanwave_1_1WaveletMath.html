<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>panwave: panwave::WaveletMath Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">panwave
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>panwave</b></li><li class="navelem"><a class="el" href="classpanwave_1_1WaveletMath.html">WaveletMath</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classpanwave_1_1WaveletMath-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">panwave::WaveletMath Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="WaveletMath_8h_source.html">WaveletMath.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:aeef307b15cb689194ff7153afb3372cc"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanwave_1_1WaveletMath.html#aeef307b15cb689194ff7153afb3372cc">Decompose</a> (const std::vector&lt; double &gt; *data, const <a class="el" href="classpanwave_1_1Wavelet.html">Wavelet</a> *wavelet, std::vector&lt; double &gt; *approx_coeffs, std::vector&lt; double &gt; *details_coeffs, DyadicMode dyadic_mode=DyadicMode::Odd, PaddingMode padding_mode=PaddingMode::Zeroes)</td></tr>
<tr class="separator:aeef307b15cb689194ff7153afb3372cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42bd6dec0f6ba9027d5ae933ad2b37a2"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanwave_1_1WaveletMath.html#a42bd6dec0f6ba9027d5ae933ad2b37a2">Reconstruct</a> (const std::vector&lt; double &gt; *coeffs, const std::vector&lt; double &gt; *reconstruction_coeffs, std::vector&lt; double &gt; *data, const <a class="el" href="classpanwave_1_1Wavelet.html">Wavelet</a> *wavelet, size_t data_size, DyadicMode dyadic_mode=DyadicMode::Odd, PaddingMode padding_mode=PaddingMode::Zeroes)</td></tr>
<tr class="separator:a42bd6dec0f6ba9027d5ae933ad2b37a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8270f19b81bdcf1a6ade62d1d2e81bea"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanwave_1_1WaveletMath.html#a8270f19b81bdcf1a6ade62d1d2e81bea">DyadicUpsample</a> (const std::vector&lt; double &gt; *data, std::vector&lt; double &gt; *data_upsampled, DyadicMode dyadic_mode=DyadicMode::Odd)</td></tr>
<tr class="separator:a8270f19b81bdcf1a6ade62d1d2e81bea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4112d5c5a2856e9c6d8bdf6ac323fea"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanwave_1_1WaveletMath.html#aa4112d5c5a2856e9c6d8bdf6ac323fea">DyadicDownsample</a> (const std::vector&lt; double &gt; *data, std::vector&lt; double &gt; *data_downsampled, DyadicMode dyadic_mode=DyadicMode::Odd)</td></tr>
<tr class="separator:aa4112d5c5a2856e9c6d8bdf6ac323fea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8d4453d5f2f7c9561ace51bcbde5204"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanwave_1_1WaveletMath.html#ad8d4453d5f2f7c9561ace51bcbde5204">Convolve</a> (const std::vector&lt; double &gt; *data, const std::vector&lt; double &gt; *coeffs, std::vector&lt; double &gt; *result)</td></tr>
<tr class="separator:ad8d4453d5f2f7c9561ace51bcbde5204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a604630ae196a80791fad5e4bf332b152"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanwave_1_1WaveletMath.html#a604630ae196a80791fad5e4bf332b152">Pad</a> (const std::vector&lt; double &gt; *data, std::vector&lt; double &gt; *extended_data, size_t pad_left, size_t pad_right, PaddingMode padding_mode=PaddingMode::Zeroes)</td></tr>
<tr class="separator:a604630ae196a80791fad5e4bf332b152"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A container for static methods useful to compute wavelet math functions. This is not meant to be a complete wavelet solution, it exists to allow the narrow set of wavelet math functions required to compute wavelet packet trees. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classpanwave_1_1WaveletPacketTree.html">WaveletPacketTree</a> </dd>
<dd>
<a class="el" href="classpanwave_1_1StationaryWaveletPacketTree.html">StationaryWaveletPacketTree</a> </dd></dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="ad8d4453d5f2f7c9561ace51bcbde5204"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8d4453d5f2f7c9561ace51bcbde5204">&#9670;&nbsp;</a></span>Convolve()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void WaveletMath::Convolve </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; *&#160;</td>
          <td class="paramname"><em>coeffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Perform a convolution. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The input signal to convolve. </td></tr>
    <tr><td class="paramname">coeffs</td><td>The filter coefficients. </td></tr>
    <tr><td class="paramname">result</td><td>The destination for our convolved signal data. Any values in the vector will be overwritten. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeef307b15cb689194ff7153afb3372cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeef307b15cb689194ff7153afb3372cc">&#9670;&nbsp;</a></span>Decompose()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void WaveletMath::Decompose </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpanwave_1_1Wavelet.html">Wavelet</a> *&#160;</td>
          <td class="paramname"><em>wavelet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; *&#160;</td>
          <td class="paramname"><em>approx_coeffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; *&#160;</td>
          <td class="paramname"><em>details_coeffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DyadicMode&#160;</td>
          <td class="paramname"><em>dyadic_mode</em> = <code>DyadicMode::Odd</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PaddingMode&#160;</td>
          <td class="paramname"><em>padding_mode</em> = <code>PaddingMode::Zeroes</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Decompose a signal into approximation and details coefficients.<br />
 Uses wavelet to get the decomposition highpass and lowpass filters. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The signal data we wish to decompose. </td></tr>
    <tr><td class="paramname">wavelet</td><td><a class="el" href="classpanwave_1_1Wavelet.html">Wavelet</a> we will use to get the highpass and lowpass decomposition filters. </td></tr>
    <tr><td class="paramname">approx_coeffs</td><td>Destination approximation coefficients. Any existing contents will be overwritten. </td></tr>
    <tr><td class="paramname">details_coeffs</td><td>Destination details coefficients. Any existing contents will be overwritten. </td></tr>
    <tr><td class="paramname">dyadic_mode</td><td>Mode we should use when dyadically downsampling. (default: Odd) </td></tr>
    <tr><td class="paramname">padding_mode</td><td>Padding mode we should use when padding the signal data. (Default: Zeroes) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa4112d5c5a2856e9c6d8bdf6ac323fea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4112d5c5a2856e9c6d8bdf6ac323fea">&#9670;&nbsp;</a></span>DyadicDownsample()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void WaveletMath::DyadicDownsample </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; *&#160;</td>
          <td class="paramname"><em>data_downsampled</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DyadicMode&#160;</td>
          <td class="paramname"><em>dyadic_mode</em> = <code>DyadicMode::Odd</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Dyadically downsample a data signal.<br />
 Half of the original values are included in the downsampled data. The dyadic mode controls which elements from the original data are taken into the downsampled data.<br />
 If dyadic mode is Even, every even index value in data is copied into the downsampled data. Odd index values are left out.<br />
 If dyadic mode is Odd, every odd index value in data is copied into the downsampled data. Even index values are left out.<br />
 The downsampled data has size half the original data's size. Even dyadic mode rounds up, Odd dyadic mode rounds down in case original data's size is not even. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The original data signal we want to downsample. </td></tr>
    <tr><td class="paramname">data_downsampled</td><td>The downsampled data will be written to this vector. Existing contents will be erased. </td></tr>
    <tr><td class="paramname">dyadic_mode</td><td>Mode we should use to dyadically downsample. (default: Odd) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>DyadicMode </dd></dl>

</div>
</div>
<a id="a8270f19b81bdcf1a6ade62d1d2e81bea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8270f19b81bdcf1a6ade62d1d2e81bea">&#9670;&nbsp;</a></span>DyadicUpsample()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void WaveletMath::DyadicUpsample </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; *&#160;</td>
          <td class="paramname"><em>data_upsampled</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DyadicMode&#160;</td>
          <td class="paramname"><em>dyadic_mode</em> = <code>DyadicMode::Odd</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Dyadically upsample a data signal.<br />
 All of the original values from data are included in the upsampled data but there are zeroes separating each value. The dyadic mode determines which indices in the upsampled vector contain zeroes.<br />
 If dyadic mode is Even, every even index in the upsampled data will contain a zero.<br />
 If dyadic mode is Odd, every odd index in the upsampled data will contain a zero.<br />
 The upsampled data has size double the original data's size plus one in even dyadic mode or minus one in odd dyadic mode. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The original data signal we want to upsample. </td></tr>
    <tr><td class="paramname">data_upsampled</td><td>The upsampled data will be written to this vector. Existing contents will be erased. </td></tr>
    <tr><td class="paramname">dyadic_mode</td><td>Mode we should use to dyadically upsample. (default: Odd) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>DyadicMode </dd></dl>

</div>
</div>
<a id="a604630ae196a80791fad5e4bf332b152"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a604630ae196a80791fad5e4bf332b152">&#9670;&nbsp;</a></span>Pad()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void WaveletMath::Pad </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; *&#160;</td>
          <td class="paramname"><em>extended_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pad_left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pad_right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PaddingMode&#160;</td>
          <td class="paramname"><em>padding_mode</em> = <code>PaddingMode::Zeroes</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Pad a vector by inserting elements on the right and left.<br />
 If padding_mode is Zeroes, the inserted elements are all zero.<br />
 If padding_mode is Symmetric, the inserted elements are the values closest to the beginning or end but flipped symmetrically around either the first or last element. If the requested pad length is longer than data size, the last or first element of data is used for all the elements which would overflow data.<br />
 For example, [1,2,3] symmetrically padded by 3 on the left and right produces [3,3,2,1,2,3,2,1,1] </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The original data we want to pad. </td></tr>
    <tr><td class="paramname">extended_data</td><td>The destination for our padded data. It will have length equal to pad_left + pad_right + data-&gt;size(). Any existing values will be overwritten. </td></tr>
    <tr><td class="paramname">pad_left</td><td>The number of elements to pad on the left of data. Can be zero. </td></tr>
    <tr><td class="paramname">pad_right</td><td>The number of elements to pad on the right of data. Can be zero. </td></tr>
    <tr><td class="paramname">padding_mode</td><td>Padding mode we should use to insert padding elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>PaddingMode </dd></dl>

</div>
</div>
<a id="a42bd6dec0f6ba9027d5ae933ad2b37a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42bd6dec0f6ba9027d5ae933ad2b37a2">&#9670;&nbsp;</a></span>Reconstruct()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void WaveletMath::Reconstruct </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; *&#160;</td>
          <td class="paramname"><em>coeffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; *&#160;</td>
          <td class="paramname"><em>reconstruction_coeffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpanwave_1_1Wavelet.html">Wavelet</a> *&#160;</td>
          <td class="paramname"><em>wavelet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>data_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DyadicMode&#160;</td>
          <td class="paramname"><em>dyadic_mode</em> = <code>DyadicMode::Odd</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PaddingMode&#160;</td>
          <td class="paramname"><em>padding_mode</em> = <code>PaddingMode::Zeroes</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reconstruct a signal from approximation or details coefficients. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coeffs</td><td>Either the approximation or details coefficients produced during a decomposition. </td></tr>
    <tr><td class="paramname">reconstruction_coeffs</td><td>Should be a lowpass or highpass reconstruction filter with size equal to the length of wavelet. </td></tr>
    <tr><td class="paramname">data</td><td>Destination vector for the reconstructed signal. Any existing contents will be erased. </td></tr>
    <tr><td class="paramname">wavelet</td><td><a class="el" href="classpanwave_1_1Wavelet.html">Wavelet</a> we used to do the decomposition. </td></tr>
    <tr><td class="paramname">data_size</td><td>Size of the reconstructed signal. </td></tr>
    <tr><td class="paramname">dyadic_mode</td><td>Mode we should use when dyadically upsampling. (default: Odd) </td></tr>
    <tr><td class="paramname">padding_mode</td><td>Padding mode we should use when padding the coefficient data. (Default: Zeroes) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="WaveletMath_8h_source.html">WaveletMath.h</a></li>
<li>src/WaveletMath.cc</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
